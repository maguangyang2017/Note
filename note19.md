### zaiAWT中绘画

去理解AWT绘画API怎样工作，有助于我们搞明白是什么触发了窗口环境中的绘画操作。AWT中有两种绘画操作：系统触发的绘画，和程序触发的绘画

### 系统触发的绘画操作
在系统触发的绘画操作中，系统需要一个部件显示它的内容，通常是由于下列中的原因：

•部件第一次在屏幕上显示

•部件的大小改变了

•部件显示的内容受损需要维护。(比如，先前挡住部件的其它物体移走了，于是部件被挡住的部分曝露出来。

### 程序触发的绘画操作
在程序触发的绘画操作，是部件自己决定要更新自身的内容，因为部件内部的状态改变了。(比如，监测到鼠标按钮已经按下，那么它就需要去画出按钮"被按下"时的样子

### 画图的方法
不管是谁触发了画图请求，AWT都是利用"回调"机制来实现绘画，这个机制对于“重量级”和“轻量级”的部件都是相同的。这就意味着程序应该在一个特定的可覆盖的方法中放置那些表现部件自身的的代码，并且在需要绘画的时候，工具包就会调用这个方法。这个可覆盖的方法在java.awt.Component中声明：public void paint（Graphics g）

当AWT调用这个方法时，作为参数的、负责在这个特定的部件上绘画的Graphics对象是在之前已经配置了的，拥有恰当的状态值。
•Graphics的颜色 值被设置为部件的前景。
•Graphics的字体 设置为部件的字体。
•Graphics的平移（translation） 也给设定，使用坐标(0,0)定位部件的左上角。
•Graphics的裁剪框(clip rectangle)设置为部件需要画图的区域。
程序必须使用这个Graphics(或者其派生类)对象来呈现绘画，并且可以根据自己的需要任意改变Graphics对象的属性值。
这里是一个回调绘画的简单例子，在部件的范围内呈现一个实体园：  
public void paint(Graphics g) {
        // 根据部件的范围，动态计算圆的尺寸信息。
        Dimension size = getSize();
        // 直径
        int d = Math.min(size.width, size.height);
        int x = (size.width - d)/2;
        int y = (size.height - d)/2;

        // 画圆（颜色已经预先设置为部件的前景颜色）
        g.fillOval(x, y, d, d);
        g.setColor(Color.black);
        g.drawOval(x, y, d, d);
    }
一般情况下，程序应该避免把绘画代码放置在回调方法paint()的范围之外。为什么呢？因为paint方法之外的绘画代码可能会在不适合画图的时候被调用 -- 例如，在部件变为可见之前或者已经在使用一个有效的Graphics。同时，不推荐在程序中直接调用paint()。

为了使能够由程序触发绘画操作，AWT提供了下面的java.awt.Component的方法，这样程序就可以提出一个异步的绘画请求：
```
    public void repaint()
    public void repaint(long tm)
    public void repaint(int x, int y, int width, int height)
    public void repaint(long tm, int x, int y,
                   int width, int height)

```
下面的代码显示了一个简单的鼠标监听器的例子，当鼠标按下和抬起的时候，使用repaint()来触发“假想按钮”的更新操作。
```
        MouseListener l = new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                MyButton b = (MyButton)e.getSource();
                b.setSelected(true);
                b.repaint();            
            }

            public void mouseReleased(MouseEvent e) {
                MyButton b = (MyButton)e.getSource();
                b.setSelected(false);
                b.repaint();            
            }
        };
```
如果部件要呈现复杂的图形，就应该使用带参数的repaint()方法，通过参数来指定需要更新的区域。一个比较常见的错误是总是调用无参数的repaint()来提出重画请求，这个方法会重画整个部件，经常导致一些不必要的画图处理。

### paint() / update()

为什么我们要区分绘画操作是"系统触发" 还是"程序触发"呢？因为在“重量级”部件上，AWT对这两种请求的在处理上稍有不同(“轻量级”的情况将在后面介绍)，并且不幸的是与此相关的代码非常复杂，难以更改。
对于“重量级”部件，这两种方式的绘画产生于两条不同的途径，取决于是“系统触发”还是“程序触发”。

### 系统触发的绘画

那么“系统触发”的绘画操作是怎么产生的：
1.AWT确定是一部分还是整个部件需要绘画。
2.AWT促使事件分派线程调用部件的paint()方法。

### 程序触发的绘画

由程序触发的绘画的产生如下所示：
1.程序确定是一部分还是全部部件需要重画以对应内部状态的改变。
2.程序调用部件的repaint()，该方法向AWT登记了一个异步的请求 －－ 当前部件需要重画。
3.AWT促使事件分派线程去调用部件的update() 方法。
注意： 在最初的重画请求处理完成之前，如果在该部件上有多次对repaint()的调用，那么这些调用可以被合并成对update()的一次调用。决定什么时候应该合并多次请求的运算法则取决于具体的实现。如果多次请求被合并，最终被更新的区域将是所有这些请求所要求更新的区域的联合(union)。
4.如果部件没有覆盖(override)update()方法，update()的默认实现会清除部件背景（如果部件不是“轻量级”），然后只是简单地调用paint()方法。

因为作为默认的最终结果都是一样的(paint()方法被调用)，很多开发人员完全不知道一个分离的update() 方法的意义。确实，默认的update()的实现最终会转回到对paint()方法的调用，然而，如果需要，这个更新操作的 "钩子（hook）"可以使程根据不同的情况来处理程序触发的绘画。程序必须这么设想，对paint()的调用意味着Graphics的裁剪区"损坏"了并且必须全部重画；然而对update()的调用没有这种含义，它使程序做增量的绘画。

如果程序希望只把要增加的内容敷盖于已存在于该部件的像素位之上，那么就使用增量画图操作。

事实上，大多数GUI部件不需要增量绘画，所有大部分程序可以忽略update()方法，并且简单地覆盖(override)paint()来呈现部件的当前状态。这就意味着不管“系统触发”还是“程序触发”，在大多数部件上的表现从其本质上讲是是等价的。

### 绘画与轻量级部件

从应用开发人员的观点看，“轻量级”的绘画API基本上和“重量级”一样（即，你只需要覆盖paint()方法，同样，调用repaint()方法去触发绘图更新）。然而，因为AWT的“轻量级”部件的框架全部使用普通Java代码实现，在轻量级部件上绘画机制的实现方式有一些微妙的不同。

### “轻量级”部件是怎样被绘制的

“轻量级”部件需要一个处在容器体系上的“重量级”部件提供进行绘画的场所。当这个“重量级”的“祖宗”被告知要绘制自身的窗体时，它必须把这个绘画的请求转化为对其所有子孙的绘画请求。这是由java.awt.Container的paint()方法处理的，该方法调用包容于其内的所有可见的、并且与绘画区相交的轻量级部件的paint()方法。因此对于所有覆盖了paint()方法的Container子类（“轻量级”或“重量级”）需要立刻做下面的事情：
```
    public class MyContainer extends Container {
        public void paint(Graphics g) {
	    // paint my contents first...
	    // then, make sure lightweight children paint
	    Super.paint(g);
        }
    }

```


如果没有super.paint()，那么容器(container)的轻量级子孙类就不会显示出来(这是一个非常普遍的问题，自从JDK1.1初次引进“轻量级”部件之后)。

这种情况相当于注释掉了默认的Container.update()方法的执行，从而不能 使用递归去调用其轻量级子孙类的update()或者paint()方法。这就意味着任何使用update()方法实现增量绘画的重量级Container子类必须确保其轻量级子孙在需要时，能够被它的递归操作所调用从而实现重画。幸运的是，只有少数几个重量级的容器(Container)需要增量绘图，所以这个问题没有影响到大多数的程序。

### AWT绘画准则

AWT为绘制部件提供了一个简单的回调API。当你使用它是，要遵循下面的原则：
1.对于大多数程序，所有的客户区绘画代码应该被放置在部件的paint()方法中。
2.通过调用repaint()方法，程序可以触发一个将来执行的paint()调用，不能直接调用paint()方法。
3.对于界面复杂的部件，应该触发带参数的repaint()方法，使用参数定义实际需要更新的区域；而不带参数调用会导致整个部件被重画。
4.因为对repaint()的调用会首先导致update()的调用，默认地会促成paint()的调用，所以重量级部件应该覆盖update()方法以实现增量绘制，如果需要的话(轻量级部件不支持增量绘制) 。
5.覆盖了paint()方法的java.awt.Container子类应当在paint()方法中调用super.paint()以保证子部件能被绘制。
6.界面复杂的部件应该灵活地使用裁剪区来把绘画范围缩小到只包括与裁剪区相交的范围。
